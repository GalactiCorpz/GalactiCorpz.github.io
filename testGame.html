<html>

<head>
	<title>Just A Game</title>

	<style>
	#canvas {
		position: relative;
		background-color: #6495ED;
		outline: 1px solid black;
		height:480px;
		width:640px;
	}
	
	#character {
		position: absolute;
	}
	</style>
	</head>
	<body>
		<div id="canvas">
			<div id="character"></div>
		</div>
		
		<script>
		addEventListener("keydown", function(e){
			keysDown[e.keyCode] = true;
		},false);
		addEventListener("keyup", function(e){
			delete keysDown[e.keyCode];
		},false);
		
		var canvas = document.getElementById("canvas");
		
		var canvasWidth = 640;
		var canvasHeight = 480;
		var pixelsPerUnit = 8;
		
		var keysDown = {};
		var oldKeysDown = {};
		
		// The structure for a Vector with its methods
		function Vector(x,y){
			this.x = 0;
			this.y = 0;
		}
		Vector.prototype.lerp = function(startVector,endVector,percent){
				return new Vector(startVector.x + percent * ( endVector.x - startVector.x),
				startVector.y + percent * ( endVector.y - startVector.y));
			};
		Vector.prototype.toString = function(){
				return "("+this.x+":"+this.y+")";
			};
		Vector.prototype.set = function(x,y){
				this.x = x;
				this.y = y;
			};
		Vector.prototype.translate = function(x,y){
				this.x += x * pixelsPerUnit;
				this.y += y * pixelsPerUnit;
			};
			
		function Entity(){
			// Instantiate entity variables
			this.position = new Vector(0,0);
			this.sprite = new Image();
			this.velocity = new Vector();
			this.entityID = "";
			this.entity = "";
			
			// Entity update function
			// This is where code-side movement and collision detection should be done.
			this.update = function(){
				this.position.translate(this.velocity.x,this.velocity.y);
				
				// Detect screen-edge
				if(this.position.x - this.sprite.width / 2 < 0)
				{
					this.position.x = 0+(this.sprite.width/2);
				}
				if(this.position.x + this.sprite.width / 2 > canvasWidth)
				{
					this.position.x = canvasWidth-(this.sprite.width/2);
				}
				if(this.position.y - this.sprite.height / 2 < 0)
				{
					this.position.y = 0+(this.sprite.height/2);
				}
				if(this.position.y + this.sprite.height / 2 > canvasHeight)
				{
					this.position.y = canvasHeight-(this.sprite.height/2);
				}
			};
			
			this.init = function(elementID)
			{
				this.elementID = elementID;
				this.entity = document.getElementById(this.elementID);
				this.position.x = canvasWidth/2-(char.sprite.width/2);
				this.position.y = canvasHeight/2-(char.sprite.height/2);
				this.entity.style.left = (this.position.x - this.sprite.width/2) + "px";
				this.entity.style.bottom = (this.position.y - this.sprite.height/2)+ "px";
				this.entity.innerHTML = "<img src='" + this.sprite.src + "' alt='0'>";
			};
			
			// Entity draw method - This ensures that the object on the webpage is updated to the same as the code-values;
			this.draw = function(){
				this.entity.style.left = (this.position.x - this.sprite.width/2) + "px";
				this.entity.style.bottom = (this.position.y - this.sprite.height/2)+ "px";
			};
		}
		
		function Input(){
			this.v = new Vector(0,0);
			if(keysDown['W'.charCodeAt(0)]){
				this.v.y = 1;
			}else if (keysDown['S'.charCodeAt(0)]){
				this.v.y = -1;
			}
			
			if(keysDown['D'.charCodeAt(0)]){
				this.v.x = 1;
			}else if (keysDown['A'.charCodeAt(0)]){
				this.v.x = -1;
			}
			
			return this.v;
		}
		
		function lerp(a,b,t){
			return (a + t *(b-a));
		}
		function clamp(value,min,max){
			if(value < min)
				return min;
			if(value > max)
				return max;
			return value;
		}
		
		var char = new Entity();
		char.sprite.src = "spr_character.png";
		char.init("character");
		var time = (1/60);
		// This is where the magic happen, this is set to try and run at 60 frames per second (1000ms/60frames)
		setInterval(function(){
			v = Input();
			
			char.velocity.set(lerp(char.velocity.x, v.x * time * 16, 0.25),
			lerp(char.velocity.y, v.y * time * 16, 0.25));
			
			char.update();
			char.draw();
			
		},time*1000);
		
		</script>
	</body>
</html>